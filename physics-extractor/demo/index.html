<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Bonk.io 4-Way Movement Demo</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      body {
        margin: 0;
        display: flex;
        min-height: 100vh;
        background: #0d1117;
        color: #e6edf3;
      }

      #sidebar {
        width: 320px;
        padding: 24px;
        box-sizing: border-box;
        border-right: 1px solid #21262d;
      }

      #sidebar h1 {
        margin: 0 0 12px;
        font-size: 1.35rem;
      }

      #sidebar p {
        margin: 0 0 8px;
        line-height: 1.4;
        color: #9da7b3;
      }

      #sidebar ul {
        padding-left: 20px;
        margin: 12px 0;
        color: #9da7b3;
      }

      #sidebar code {
        color: #ffab70;
      }

      #sidebar label.dropdown {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.95rem;
        margin-bottom: 16px;
        color: #c9d1d9;
      }

      #sidebar label.dropdown select {
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid #30363d;
        background: #161b22;
        color: inherit;
        font-size: 0.9rem;
      }

      #sidebar label.toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        color: #c9d1d9;
        margin-top: 14px;
      }

      #sidebar label.toggle input {
        accent-color: #2ea043;
      }

      #sim-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      canvas {
        border: 1px solid #21262d;
        background: #030712;
        max-width: 100%;
      }

      #overlay {
        position: absolute;
        top: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.9rem;
        letter-spacing: 0.03em;
        color: #7ee787;
        pointer-events: none;
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
      }

      button {
        padding: 8px 14px;
        background: #238636;
        color: #fff;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        font-size: 0.9rem;
      }

      button:hover {
        background: #2ea043;
      }
    </style>
  </head>
  <body>
    <aside id="sidebar">
      <h1>Bonk Physics Sandbox</h1>
      <p>
        This tiny canvas world uses the numbers we measured so far: gravity at
        9.5 ball-diameters/sÂ², up-thrust 5.7, down-thrust 5.7, and horizontal
        thrust 5.45. One ball diameter is treated as one meter.
      </p>
      <label class="dropdown">
        <span>Map</span>
        <select id="map-select"></select>
      </label>
      <label class="dropdown">
        <span>P2 AI</span>
        <select id="ai-select"></select>
      </label>
      <p>Controls:</p>
      <ul>
        <li>
          <strong>P1</strong>: <code>ArrowLeft / ArrowRight</code> for thrust,
          <code>ArrowUp</code> to jump, <code>ArrowDown</code> to descend faster
        </li>
        <li>
          <strong>P2</strong>: <code>A / D</code> for thrust, <code>W</code> to
          jump, <code>S</code> to descend faster
        </li>
        <li><code>R</code> &rarr; reset position/velocity</li>
      </ul>
      <p>
        There is no air drag or ground friction, so releasing the keys lets the
        ball coast forever. Hold UP while airborne to see the slower drop that
        matches the continuous-hold recordings, or hold DOWN to slam/shorten
        jumps. Falling below the arena respawns you at the latest spawn.
      </p>
      <label class="toggle">
        <input type="checkbox" id="velocity-toggle" />
        Show velocity vector
      </label>
    </aside>
    <div id="sim-container">
      <canvas id="sim" width="960" height="600"></canvas>
      <div id="overlay"></div>
      <div style="margin-top: 16px">
        <button id="reset-btn">Reset (R)</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("sim");
      const ctx = canvas.getContext("2d");
      const overlay = document.getElementById("overlay");
      const mapSelect = document.getElementById("map-select");
      const aiSelect = document.getElementById("ai-select");
      const velocityToggle = document.getElementById("velocity-toggle");

      const PX_PER_M = 42; // zoomed out to show more map per ball diameter.
      const BALL_DIAMETER = 1;
      const BALL_RADIUS = BALL_DIAMETER / 2;
      const GRAVITY = -9.5;
      const UP_THRUST = 5.7;
      const DOWN_THRUST = 5.7; // matches UP magnitude; flips net accel downward.
      const H_THRUST = 5.45;
      const TAP_APEX = 1.2;
      const JUMP_SPEED = Math.sqrt(2 * Math.abs(GRAVITY) * TAP_APEX);
      const PLAYER_RESTITUTION = 0.4;

      const MAPS = [
        {
          id: "mini-course",
          name: "Mini Course",
          world: {
            floorLevel: 0,
            ceiling: 9.2,
            left: -11.5,
            right: 11.5,
          },
          obstacles: [
            { x: -12.5, y: -1, w: 25, h: 1 }, // floor slab
            { x: -12.5, y: 0, w: 1, h: 8 }, // left wall
            { x: 11.5, y: 0, w: 1, h: 8 }, // right wall
            { x: -4.5, y: 2.2, w: 5, h: 0.4 },
            { x: 4, y: 3.8, w: 3.5, h: 0.4 },
            { x: -9.5, y: 1.2, w: 2.5, h: 1.4 },
          ],
          spawnPoints: [
            { x: -8, y: 1.3 },
            { x: -6, y: 1.3 },
          ],
          killPlane: -3.5,
        },
        {
          id: "flat-1v1",
          name: "Flat 1v1",
          world: {
            floorLevel: -2,
            ceiling: 9.2,
            left: -11.5,
            right: 11.5,
          },
          obstacles: [
            { x: -5, y: 2.8, w: 10, h: 0.35 }, // suspended dueling platform
          ],
          spawnPoints: [
            { x: -3.8, y: 3.2 },
            { x: 3.8, y: 3.2 },
          ],
          killPlane: -4.5,
        },
      ];

      const AI_MODES = [
        { id: "none", name: "None" },
        { id: "simple-xy", name: "Simple XY comparison" },
      ];

      const PLAYER_CONFIGS = [
        {
          label: "P1",
          color: "#d1d5db",
          controls: {
            left: "ArrowLeft",
            right: "ArrowRight",
            up: "ArrowUp",
            down: "ArrowDown",
          },
          defaultAiMode: "none",
        },
        {
          label: "P2",
          color: "#4b5563",
          controls: {
            left: "KeyA",
            right: "KeyD",
            up: "KeyW",
            down: "KeyS",
          },
          defaultAiMode: "none",
        },
      ];

      const keys = new Set();
      let showVelocityVector = false;
      let currentMap = MAPS[0];
      let world = { ...currentMap.world };
      let obstacles = currentMap.obstacles;
      let killPlane = currentMap.killPlane;

      const players = PLAYER_CONFIGS.map((config, index) => ({
        label: config.label,
        color: config.color,
        controls: config.controls,
        index,
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        touchingGround: false,
        aiMode: config.defaultAiMode ?? "none",
        aiIntent: { left: false, right: false, up: false, down: false },
      }));

      function createBlankIntent() {
        return { left: false, right: false, up: false, down: false };
      }

      function respawnPlayer(player) {
        const spawnList = currentMap.spawnPoints ?? [];
        let spawn = null;
        if (spawnList.length > 0) {
          spawn =
            spawnList[player.index % spawnList.length] ??
            spawnList[spawnList.length - 1];
        }
        if (!spawn) {
          spawn = { x: 0, y: 1.5 };
        }
        player.x = spawn.x;
        player.y = spawn.y;
        player.vx = 0;
        player.vy = 0;
        player.touchingGround = false;
        player.aiIntent = createBlankIntent();
      }

      function respawnAllPlayers() {
        players.forEach(respawnPlayer);
      }

      function loadMap(mapId) {
        const nextMap = MAPS.find((map) => map.id === mapId) ?? MAPS[0];
        currentMap = nextMap;
        world = { ...nextMap.world };
        obstacles = nextMap.obstacles;
        killPlane = nextMap.killPlane ?? nextMap.world.floorLevel - 4;
        respawnAllPlayers();
      }

      function initMapSelect() {
        MAPS.forEach((map) => {
          const option = document.createElement("option");
          option.value = map.id;
          option.textContent = map.name;
          mapSelect.appendChild(option);
        });
        mapSelect.value = currentMap.id;
        mapSelect.addEventListener("change", (event) => {
          loadMap(event.target.value);
        });
      }

      function initAISelect() {
        AI_MODES.forEach((mode) => {
          const option = document.createElement("option");
          option.value = mode.id;
          option.textContent = mode.name;
          aiSelect.appendChild(option);
        });
        if (players[1]) {
          aiSelect.value = players[1].aiMode;
        }
        aiSelect.addEventListener("change", (event) => {
          if (players[1]) {
            players[1].aiMode = event.target.value;
          }
        });
      }

      document.getElementById("reset-btn").addEventListener("click", respawnAllPlayers);
      velocityToggle.addEventListener("change", () => {
        showVelocityVector = velocityToggle.checked;
      });
      initMapSelect();
      initAISelect();

      window.addEventListener("keydown", (ev) => {
        const preventList = [
          "ArrowLeft",
          "ArrowRight",
          "ArrowUp",
          "ArrowDown",
          "KeyA",
          "KeyD",
          "KeyW",
          "KeyS",
        ];
        if (preventList.includes(ev.code)) {
          ev.preventDefault();
        }
        keys.add(ev.code);

        if (ev.code === "KeyR") {
          respawnAllPlayers();
        }
      });

      window.addEventListener("keyup", (ev) => {
        keys.delete(ev.code);
      });

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function resolveCircleRect(ball, rect) {
        const closestX = clamp(ball.x, rect.x, rect.x + rect.w);
        const closestY = clamp(ball.y, rect.y, rect.y + rect.h);
        let dx = ball.x - closestX;
        let dy = ball.y - closestY;
        const distSq = dx * dx + dy * dy;
        const radiusSq = BALL_RADIUS * BALL_RADIUS;
        if (distSq >= radiusSq) {
          return;
        }

        let dist = Math.sqrt(distSq);
        if (dist === 0) {
          dist = 1e-6;
          dx = 0;
          dy = 1;
        }

        const overlap = BALL_RADIUS - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        ball.x += nx * overlap;
        ball.y += ny * overlap;

        const vn = ball.vx * nx + ball.vy * ny;
        if (vn < 0) {
          ball.vx -= vn * nx;
          ball.vy -= vn * ny;
        }

        if (ny > 0.6) {
          // Only treat this as support when the ball's center is over the top face.
          const centerAboveSurface = ball.x >= rect.x - 1e-6 && ball.x <= rect.x + rect.w + 1e-6;
          if (centerAboveSurface) ball.touchingGround = true;
        }
      }

      function resolvePlayerPair(a, b) {
        let dx = b.x - a.x;
        let dy = b.y - a.y;
        const minDist = BALL_DIAMETER;
        let distSq = dx * dx + dy * dy;
        if (distSq === 0) {
          dx = 1e-6;
          dy = 0;
          distSq = dx * dx + dy * dy;
        }
        const dist = Math.sqrt(distSq);
        if (dist >= minDist) {
          return;
        }

        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        const correction = overlap / 2;
        a.x -= nx * correction;
        a.y -= ny * correction;
        b.x += nx * correction;
        b.y += ny * correction;

        const relVx = b.vx - a.vx;
        const relVy = b.vy - a.vy;
        const relVelAlongNormal = relVx * nx + relVy * ny;
        if (relVelAlongNormal > 0) {
          return;
        }

        const j = (-(1 + PLAYER_RESTITUTION) * relVelAlongNormal) / 2;
        a.vx -= j * nx;
        a.vy -= j * ny;
        b.vx += j * nx;
        b.vy += j * ny;
      }

      function resolvePlayerCollisions() {
        for (let i = 0; i < players.length; i++) {
          for (let j = i + 1; j < players.length; j++) {
            resolvePlayerPair(players[i], players[j]);
          }
        }
      }

      function computeSimpleXYIntent(player, target) {
        const intent = createBlankIntent();
        if (!target) return intent;
        const tol = 0.05;
        if (player.x < target.x - tol) intent.right = true;
        else if (player.x > target.x + tol) intent.left = true;
        if (player.y < target.y - tol) intent.up = true;
        else if (player.y > target.y + tol) intent.down = true;
        return intent;
      }

      function updateAIIntents() {
        const reference = players[0];
        players.forEach((player) => {
          player.aiIntent = createBlankIntent();
          if (player.aiMode === "simple-xy" && player !== reference && reference) {
            player.aiIntent = computeSimpleXYIntent(player, reference);
          }
        });
      }

      function physicsStep(dt) {
        players.forEach((player) => {
          const controls = player.controls;
          const intent = player.aiIntent ?? createBlankIntent();
          let ax = 0;
          if (keys.has(controls.left) || intent.left) ax -= H_THRUST;
          if (keys.has(controls.right) || intent.right) ax += H_THRUST;

          let ay = GRAVITY;
          if (keys.has(controls.up) || intent.up) ay += UP_THRUST;
          if (keys.has(controls.down) || intent.down) ay -= DOWN_THRUST;

          player.vx += ax * dt;
          player.vy += ay * dt;
          player.x += player.vx * dt;
          player.y += player.vy * dt;

          player.touchingGround = false;
          obstacles.forEach((rect) => resolveCircleRect(player, rect));

          if ((keys.has(controls.up) || intent.up) && player.touchingGround && player.vy <= 0) {
            player.vy = JUMP_SPEED;
            player.touchingGround = false;
          }

          player.x = clamp(player.x, world.left + BALL_RADIUS, world.right - BALL_RADIUS);
          if (player.x <= world.left + BALL_RADIUS && player.vx < 0) player.vx = 0;
          if (player.x >= world.right - BALL_RADIUS && player.vx > 0) player.vx = 0;

          const ceiling = world.ceiling - BALL_RADIUS;
          if (player.y > ceiling) {
            player.y = ceiling;
            if (player.vy > 0) player.vy = 0;
          }

          if (player.y < killPlane) {
            respawnPlayer(player);
          }
        });
        resolvePlayerCollisions();
      }

      function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height - 80);
        ctx.scale(1, -1);
        ctx.scale(PX_PER_M, PX_PER_M);

        ctx.lineWidth = 1 / PX_PER_M;
        ctx.strokeStyle = "rgba(94, 94, 121, 0.25)";
        ctx.beginPath();
        const gridSpacing = 1;
        const gridPadding = 2;
        const minX = Math.floor(world.left - gridPadding);
        const maxX = Math.ceil(world.right + gridPadding);
        const minY = Math.floor((world.floorLevel ?? -2) - gridPadding);
        const maxY = Math.ceil(world.ceiling + gridPadding);
        for (let x = minX; x <= maxX; x += gridSpacing) {
          ctx.moveTo(x, minY);
          ctx.lineTo(x, maxY);
        }
        for (let y = minY; y <= maxY; y += gridSpacing) {
          ctx.moveTo(minX, y);
          ctx.lineTo(maxX, y);
        }
        ctx.stroke();

        ctx.fillStyle = "#4b5563";
        obstacles.forEach((rect) => {
          ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        });

        players.forEach((player) => {
          ctx.fillStyle = player.color;
          ctx.beginPath();
          ctx.arc(player.x, player.y, BALL_RADIUS, 0, Math.PI * 2);
          ctx.fill();

          if (showVelocityVector) {
            ctx.strokeStyle = "#f85149";
            ctx.lineWidth = 2 / PX_PER_M;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(player.x + player.vx * 0.15, player.y + player.vy * 0.15);
            ctx.stroke();
          }
        });

        ctx.restore();

        overlay.textContent = players
          .map(
            (player) =>
              `${player.label}: (${player.x.toFixed(2)} m, ${player.y.toFixed(2)} m)` +
              `  v=(${player.vx.toFixed(2)} m/s, ${player.vy.toFixed(2)} m/s)`
          )
          .join("    ");
      }

      let last = performance.now();
      function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        const clampedDt = Math.min(dt, 1 / 30);
        updateAIIntents();
        physicsStep(clampedDt);
        drawScene();
        requestAnimationFrame(loop);
      }

      respawnAllPlayers();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
