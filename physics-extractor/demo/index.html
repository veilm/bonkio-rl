<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Bonk.io 4-Way Movement Demo</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      body {
        margin: 0;
        display: flex;
        min-height: 100vh;
        background: #0d1117;
        color: #e6edf3;
      }

      #sidebar {
        width: 320px;
        padding: 24px;
        box-sizing: border-box;
        border-right: 1px solid #21262d;
      }

      #sidebar h1 {
        margin: 0 0 12px;
        font-size: 1.35rem;
      }

      #sidebar p {
        margin: 0 0 8px;
        line-height: 1.4;
        color: #9da7b3;
      }

      #sidebar ul {
        padding-left: 20px;
        margin: 12px 0;
        color: #9da7b3;
      }

      #sidebar code {
        color: #ffab70;
      }

      #sidebar label.toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        color: #c9d1d9;
        margin-top: 14px;
      }

      #sidebar label.toggle input {
        accent-color: #2ea043;
      }

      #sim-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      canvas {
        border: 1px solid #21262d;
        background: #030712;
        max-width: 100%;
      }

      #overlay {
        position: absolute;
        top: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.9rem;
        letter-spacing: 0.03em;
        color: #7ee787;
        pointer-events: none;
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
      }

      button {
        padding: 8px 14px;
        background: #238636;
        color: #fff;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        font-size: 0.9rem;
      }

      button:hover {
        background: #2ea043;
      }
    </style>
  </head>
  <body>
    <aside id="sidebar">
      <h1>Bonk Physics Sandbox</h1>
      <p>
        This tiny canvas world uses the numbers we measured so far: gravity at
        9.5 ball-diameters/sÂ², up-thrust 5.7, down-thrust 5.7, and horizontal
        thrust 5.45. One ball diameter is treated as one meter.
      </p>
      <p>Controls:</p>
      <ul>
        <li><code>ArrowLeft / ArrowRight</code> &rarr; lateral thrust (hold)</li>
        <li>
          <code>ArrowUp</code> &rarr; tap to jump once, hold to auto-hop
        </li>
        <li><code>ArrowDown</code> &rarr; hold to descend faster</li>
        <li><code>R</code> &rarr; reset position/velocity</li>
      </ul>
      <p>
        There is no air drag or ground friction, so releasing the keys lets the
        ball coast forever. Hold UP while airborne to see the slower drop that
        matches the continuous-hold recordings, or hold DOWN to slam/shorten
        jumps.
      </p>
      <label class="toggle">
        <input type="checkbox" id="velocity-toggle" />
        Show velocity vector
      </label>
    </aside>
    <div id="sim-container">
      <canvas id="sim" width="960" height="600"></canvas>
      <div id="overlay"></div>
      <div style="margin-top: 16px">
        <button id="reset-btn">Reset (R)</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("sim");
      const ctx = canvas.getContext("2d");
      const overlay = document.getElementById("overlay");
      const velocityToggle = document.getElementById("velocity-toggle");

      const PX_PER_M = 42; // zoomed out to show more map per ball diameter.
      const BALL_DIAMETER = 1;
      const BALL_RADIUS = BALL_DIAMETER / 2;
      const GRAVITY = -9.5;
      const UP_THRUST = 5.7;
      const DOWN_THRUST = 5.7; // matches UP magnitude; flips net accel downward.
      const H_THRUST = 5.45;
      const TAP_APEX = 1.2;
      const JUMP_SPEED = Math.sqrt(2 * Math.abs(GRAVITY) * TAP_APEX);
      const WORLD = {
        floorLevel: 0,
        ceiling: 9.2,
        left: -11.5,
        right: 11.5,
      };

      const obstacles = [
        { x: -12.5, y: -1, w: 25, h: 1 }, // floor slab
        { x: -12.5, y: 0, w: 1, h: 8 }, // left wall
        { x: 11.5, y: 0, w: 1, h: 8 }, // right wall
        { x: -4.5, y: 2.2, w: 5, h: 0.4 },
        { x: 4, y: 3.8, w: 3.5, h: 0.4 },
        { x: -9.5, y: 1.2, w: 2.5, h: 1.4 },
      ];

      const keys = new Set();
      let showVelocityVector = false;

      const state = {
        x: -8,
        y: 1.3,
        vx: 0,
        vy: 0,
        touchingGround: false,
      };

      function resetState() {
        state.x = -8;
        state.y = 1.3;
        state.vx = 0;
        state.vy = 0;
      }

      document.getElementById("reset-btn").addEventListener("click", resetState);
      velocityToggle.addEventListener("change", () => {
        showVelocityVector = velocityToggle.checked;
      });

      window.addEventListener("keydown", (ev) => {
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(ev.code)) {
          ev.preventDefault();
        }
        keys.add(ev.code);

        if (ev.code === "KeyR") {
          resetState();
        }
      });

      window.addEventListener("keyup", (ev) => {
        keys.delete(ev.code);
      });

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function resolveCircleRect(ball, rect) {
        const closestX = clamp(ball.x, rect.x, rect.x + rect.w);
        const closestY = clamp(ball.y, rect.y, rect.y + rect.h);
        let dx = ball.x - closestX;
        let dy = ball.y - closestY;
        const distSq = dx * dx + dy * dy;
        const radiusSq = BALL_RADIUS * BALL_RADIUS;
        if (distSq >= radiusSq) {
          return;
        }

        let dist = Math.sqrt(distSq);
        if (dist === 0) {
          dist = 1e-6;
          dx = 0;
          dy = 1;
        }

        const overlap = BALL_RADIUS - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        ball.x += nx * overlap;
        ball.y += ny * overlap;

        const vn = ball.vx * nx + ball.vy * ny;
        if (vn < 0) {
          ball.vx -= vn * nx;
          ball.vy -= vn * ny;
        }

        if (ny > 0.6) {
          state.touchingGround = true;
        }
      }

      function physicsStep(dt) {
        let ax = 0;
        if (keys.has("ArrowLeft")) ax -= H_THRUST;
        if (keys.has("ArrowRight")) ax += H_THRUST;

        let ay = GRAVITY;
        if (keys.has("ArrowUp")) ay += UP_THRUST;
        if (keys.has("ArrowDown")) ay -= DOWN_THRUST;

        state.vx += ax * dt;
        state.vy += ay * dt;
        state.x += state.vx * dt;
        state.y += state.vy * dt;

        state.touchingGround = false;

        obstacles.forEach((rect) => resolveCircleRect(state, rect));

        if (keys.has("ArrowUp") && state.touchingGround && state.vy <= 0) {
          state.vy = JUMP_SPEED;
          state.touchingGround = false;
        }

        state.x = clamp(state.x, WORLD.left + BALL_RADIUS, WORLD.right - BALL_RADIUS);
        if (state.x <= WORLD.left + BALL_RADIUS && state.vx < 0) state.vx = 0;
        if (state.x >= WORLD.right - BALL_RADIUS && state.vx > 0) state.vx = 0;

        const ceiling = WORLD.ceiling - BALL_RADIUS;
        if (state.y > ceiling) {
          state.y = ceiling;
          if (state.vy > 0) state.vy = 0;
        }
      }

      function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height - 80);
        ctx.scale(1, -1);
        ctx.scale(PX_PER_M, PX_PER_M);

        ctx.lineWidth = 1 / PX_PER_M;
        ctx.strokeStyle = "rgba(94, 94, 121, 0.25)";
        ctx.beginPath();
        const gridSpacing = 1;
        for (let x = -15; x <= 15; x += gridSpacing) {
          ctx.moveTo(x, -2);
          ctx.lineTo(x, 9);
        }
        for (let y = -2; y <= 9; y += gridSpacing) {
          ctx.moveTo(-15, y);
          ctx.lineTo(15, y);
        }
        ctx.stroke();

        ctx.fillStyle = "#20283a";
        obstacles.forEach((rect) => {
          ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        });

        ctx.fillStyle = "#58a6ff";
        ctx.beginPath();
        ctx.arc(state.x, state.y, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        if (showVelocityVector) {
          ctx.strokeStyle = "#f85149";
          ctx.lineWidth = 2 / PX_PER_M;
          ctx.beginPath();
          ctx.moveTo(state.x, state.y);
          ctx.lineTo(state.x + state.vx * 0.15, state.y + state.vy * 0.15);
          ctx.stroke();
        }

        ctx.restore();

        overlay.textContent = `pos: (${state.x.toFixed(2)} m, ${state.y.toFixed(
          2
        )} m)   vel: (${state.vx.toFixed(2)} m/s, ${state.vy.toFixed(
          2
        )} m/s)`;
      }

      let last = performance.now();
      function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        const clampedDt = Math.min(dt, 1 / 30);
        physicsStep(clampedDt);
        drawScene();
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    </script>
  </body>
</html>
